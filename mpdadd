#!/usr/bin/env ruby

# Standart ruby library, no extra packages required
require 'fileutils'
require 'getoptlong'

# comment this line out if you use the gem version of 'librmpd'
#require 'rubygems' 
require 'librmpd' # avaible in gems and in AUR in Archlinux

class Config
	# In the futur a configuration should be processed.
	Music_dir = '~/music'
	Links_dirname = 'link'
	MPD_ip = 'localhost'
	MPD_port = 6600
	Password = nil # is passed as plaintext
end

module Info
	Name = File.basename $0
	Description = 'Add all songs on your harddrive to your local MPD'
	Author = 'Joerg T. aka Mic92'
	Version = 0.1
	Homepage = 
end

class Mpdadd
	def parse_arguments
		switches = GetoptLong.new(
			[ '--help', '-h', GetoptLong::NO_ARGUMENT ],
			[ '--play', '-p', GetoptLong::NO_ARGUMENT ], 
			[ '--verbose', '-v', GetoptLong::NO_ARGUMENT ],
			[ '--version', GetoptLong::NO_ARGUMENT ] 
		)

		# Default options
		options = {}
		options[:help] = false 
		options[:play] = false
		options[:verbose] = false
		options[:version] = false
		options[:files] = []

		switches.each do |opt|
			case opt 
			when '--help' 
				options[:help] = true
			when '--play'
				options[:play] = true
			when '--verbose'
				options[:verbose] = true
			when '--version'
				options[:version] = true
			end
		end

		# The rest args are files/directorys hopefully.
		options[:files] = ARGV 
		return options
	end

	def validate_options(options)
		puts 'Validate options...' if options[:verbose]
		if options[:help]
			show_usage
			exit 0
		elsif options[:version]
			show_version
			exit 0
		elsif !options[:files].empty? # test all files, wheter they exist.
			validate_files = []

		  options[:files].each do |file|
				if !File.exist? file
					puts "File #{file} does not exist"
					next
				end
				validate_files << file
			end

			options[:files] = validate_files
		else # The user does not give any arguments
			show_usage
			exit 0
		end
		return options
	end

	def add_files(options, mpc)
		options[:files].each do |file|
			path = File.expand_path file 
			relativ_path = ""

			puts 'Enqueing: '+File.basename(file) if options[:verbose]
			# if the given path is within music dir just add it 
			if path.index( MPC::Full_music_path ) == 0
				relativ_path = path[MPC::Full_music_path.length+1, path.length]
			else  # else link and force MPD update
				puts 'Force link!' if options[:verbose]
				unique = generate_unique path # replace directory delimiter with !
				FileUtils.ln_sf path, File.join(MPC::Full_links_path, unique)
				relativ_path = File.join(Config::Links_dirname, unique)
			end

			times = 1
			begin
				puts 'Update MPD\'s Database' if options[:verbose]
				mpc.update relativ_path
				puts "Add '#{relativ_path}' to Playlist" if options[:verbose]
				mpc.add relativ_path
			rescue
				times++
					max_retries = times < 3
				retry unless max_retries
			end
		end
		return options
	end

	def generate_unique(path)
		# EXPERIMENTAL Help me to test this on windows
		if RUBY_PLATFORM =~ /(win|w)32$/
			return path.gsub('\\', '!')
		else
			return path.gsub('/', '!')
		end
	end

	def show_usage
		puts <<-EOF
#{Info::Description}
#{Info::Name} [Options] [files or directories]
  --play,     -p  play the first file added
  --help,     -h  show this help
  --verbose   -v  verbose logging
  --recursive -r  include subdirs 
  --version       show version number 
	EOF
	end

	def show_version
		puts "Version: #{Info::Version}"
		puts "Author: #{Info::Author}"
		puts "Source: #{Info::Homepage}"
	end

	def initialize
		options = validate_options(parse_arguments)

		puts 'Try to connect to MPD' if options[:verbose]
		mpc = MPC.new

		add_files(options, mpc)

		if options[:play]
			puts 'Playing...' if options[:verbose]
			mpc.play mpc.nextsong
		end

		puts 'Finished successful!' if options[:verbose]
    exit 0
	end

	private :parse_arguments, :validate_options, :add_files, :generate_unique,  :show_usage, :show_version
end

class MPC < MPD
	Full_music_path = File.expand_path(Config::Music_dir)
	Full_links_path = File.join(Full_music_path, Config::Links_dirname)

	def validate_config
		if !File.exist? Full_music_path
			warn "Given music directory '#{Config::Music_dir}' does not exist"
			return false
		elsif !File.exist? Full_links_path 
			print "Given link directory '#{Config::Links_dirname}' doesn't exists, create it? y or n?";
			yes = (STDIN.gets =~ /^y.*/i)
			if yes then
				begin
					FileUtils.mkpath Full_links_path 
				rescue
					warn "Can't create #$!."
					return false 
				end
			end
		end
		return true
	end

	def try_connect
		begin
			connect
		rescue
			warn "Can't connect to MPD: #{Config::MPD_ip}:#{Config::MPD_port}"
		  return false
		end
	end

	def initialize
		super(Config::MPD_ip, Config::MPD_port)
		password(Config::Password) if Config::Password != nil

		exit 1 unless validate_config and try_connect

		@nextsong = status['playlistlength'].to_i
	end

	private :try_connect, :validate_config
	attr_accessor :nextsong
end

Mpdadd.new
